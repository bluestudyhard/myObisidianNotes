
### 学习建议

然后就是，要把基础打好，比如说js的对象，原型，一些常用方法的使用，我们总是忘记那几个经典对象的使用，这是不行的。

先过一遍全部的用法，比如组件式，选项式那些api，然后再把组件化搞好，最后整整路由

然后就是可以动手实现一下小项目，实现的过程中要注意规范，然后仿一下apple或者什么高级的网站，用vue实现一下，这样在前端方面就差不多了，然后就要去学node，然后就是node的框架，koa什么的。

我们这个学期的目标是做一个类似chat的网站，前后端不分离的本地项目，



### 学的一堆先堆着到时候再整理
- 关于响应式和组合式，响应式其实和微信小程序那种一样，在js里，有个大page()，然后有data，method需要暴露出来才能调用，但是很容易造成堆积
- 组合式的话就是，利用ref这种组合数控件，比如``` const count = ref(0)``` 随即使用，就不用预先要定义了，但其实这两种没差
- `ref()`用于将基本数据类型（如数字、字符串等）转换为响应式对象，然后他也可以定义对象，就是他调用的时候，要多调用一个.value.xx

ref本身就是一个对象，只有一个value值




- 而`reactive()` 也可以转普通的数据类型和对象，变得和ref没啥区别了，可能是vue3中修改了，以前是（不能定义普通对象的。）
- 那就ref在普通数据的时候用，reactive在复杂对象的时候用就好了。

- computed

```
// 组件中
function calculateBooksMessage() {
  return author.books.length > 0 ? 'Yes' : 'No'
}
```

若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数。

这也解释了为什么下面的计算属性永远不会更新，因为 `Date.now()` 并不是一个响应式依赖：

js

```
const now = computed(() => Date.now())
```